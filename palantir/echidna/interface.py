from maat import Cst, EVMTransaction, Value, VarContext
from typing import Dict, Final, List, Tuple, Union
from ..common.exceptions import EchidnaException, GenericException
from ..common.abi import function_call
from ..common.logger import logger

import os
import json

# Prefix for files containing new inputs generated by the symbolic executor
NEW_INPUT_PREFIX: Final[str] = "optik_solved_input"


def translate_argument(arg: Dict) -> Tuple[str, Union[bytes, int, Value]]:
    """Translate a parsed Echidna transaction argument into a '(type, value)' tuple.
    :param arg: Transaction argument parsed as a json dict"""
    if arg["tag"] == "AbiUInt":
        bits = arg["contents"][0]
        val = int(arg["contents"][1])
        return (
            f"uint{bits}",
            val,
        )
    else:
        raise EchidnaException(f"Unsupported argument type: {arg['tag']}")


def load_tx(tx: Dict) -> EVMTransaction:
    """Translates a parsed echidna transaction into a Maat transaction
    :param tx: Echidna transaction parsed as a json dict"""

    # Translate function call and argument types and values
    call = tx["_call"]
    if call["tag"] != "SolCall":
        raise EchidnaException(f"Unsupported transaction type: '{call['tag']}'")

    arg_types = []
    arg_values = []
    func_name = call["contents"][0]
    if len(call["contents"]) > 1:
        for arg in call["contents"][1]:
            t, val = translate_argument(arg)
            arg_types.append(t)
            arg_values.append(val)

    func_signature = f"({','.join(arg_types)})"
    call_data = function_call(func_name, func_signature, *arg_values)

    # Build transaction
    # TODO: correctly handle gas_limit
    # TODO: make EVMTransaction accept integers as arguments
    sender = Cst(256, int(tx["_src"], 16))
    value = Cst(256, int(tx["_value"], 16))
    gas_limit = Cst(256, 46546514651)
    recipient = int(tx["_dst"], 16)
    return EVMTransaction(
        sender,  # origin
        sender,  # sender
        recipient,  # recipient
        value,  # value
        call_data,  # data
        gas_limit,  # gas_limit
    )


def load_tx_sequence(filename: str) -> List[EVMTransaction]:
    """Load a sequence of transactions from an Echidna corpus file
    :param filename: corpus file to load
    """
    with open(filename, "rb") as f:
        data = json.loads(f.read())
        return [load_tx(tx) for tx in data]


def store_tx(old_file: str, new_args: VarContext) -> None:
    """Serialize a new input corpus

    :param old_file: the corpus file this new input is derived from
    :param new_args: the arguments to pass in"""

    with open(old_file, "rb") as f:
        data = json.loads(f.read())

    # TODO: needs to be able to handle multiple function parameters
    call = data[0]["_call"]

    for i, arg in enumerate(call["contents"][1]):
        data[0]["_call"]["contents"][1][i]["contents"][1] = str(new_args)

    new_file = get_available_filename(
        f"{os.path.dirname(old_file)}/{NEW_INPUT_PREFIX}", ".txt"
    )

    with open(new_file, "w") as f:
        json.dump(data, f)


def get_available_filename(prefix: str, suffix: str) -> str:
    """Get an avaialble filename. The filename will have the
    form '<prefix>_<num><suffix>' where <num> is automatically
    generated based on existing files

    :param prefix: the new file prefix, including potential absolute the path
    :param suffix: the new file suffix
    """
    num = 0
    num_max = 100000
    while os.path.exists(f"{prefix}_{num}{suffix}") and num < num_max:
        num += 1
    if num >= num_max:
        raise GenericException("Can't find available filename, very odd")
    return f"{prefix}_{num}{suffix}"
